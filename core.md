来设计一下加密工具的内核功能层吧，由于是分层设计，所以先来完成内核层，内核层的就是为了能够向表示层提供服务的，所以也算是一个前后端分离的项目了。同时还有一个适配层，用来适配不同执行环境，不同浏览器或者node，之所以要支持node，是因为一些测试应该在本地完成，最好变成cicd的一部分。

## 内核功能模块

整个内核层本身就是一个对象，然后对外暴露了一些接口，并不是一个工具集，使用者将它作为全局对象就可以了。

下面来说明一下内核层需要支持的任务：

### 文件管理

需要能够支持文件的读取和保存，操作的对象包含本地文件系统、浏览器存储、webdav等。

同时还要处理文件的更新，关于更新策略是否可以允许简单地进行覆盖？应该是不行的，由于是分布式的，所以不可以用任何一个副本去更新远端的内容，也不可以用远端的内容来覆盖。

想下下面这种情况，本地有了项A、B、C、D，而远端有A、B、E，如果简单使用远端内容来覆盖本地，就会导致本地的C/D消失了，所以我们只应该更新而不应该覆盖。在格式设计中，我打算为每个记录增加一个uuid，所以大概看起来会是这样的：

```json
{
    "records": {
    	<UUID>: {}
	}
}
```

这样我们可以很快察觉出来，远端多了一个E，最终结果就是A、B、C、D、E，之后更新到远端之后远端的内容也同步了。

如果出现了冲突怎么办？就是同一个对象的内容不同了，有两个策略，一个是直接用远程的内容覆盖，另外一个是让用户选择是否用远程的内容覆盖，这里我们先实现第一种策略。

还有一个问题就是我们一个需要支持纯本地的记录，这个可以允许用户来进行配置，每次同步之前，先过滤出这些内容。

### 状态管理

对整个加密工具的状态进行管理，例如设置自动关闭时间之类的，还有就是保存一个PIN的状态，是否过期，是否能够使用。



### 加密解密

这里需要考虑的问题是到底应该对每个密码进行加密还是对整个文件都加密？为了能够进行管理，应该是对每个密码都进行加密，不只是密码，包括描述之类的东西也一个进行加密，这样文件被拿下了也不会有什么问题。

我这里有一个问题，如果我加密的内容是一段人类语言，那么是不是相对于一段乱码好破解的多？因为破译者只需要最终确认这段话是人类语言，那么它就知道自己破译成功了，同时获取了密钥。

### 配置管理



## 文件格式设置

如何去实现这个文件格式？

除了密码记录之外，我还需要支持自定义字段，也就是说用户可以创建一个模板来指定，然后通过模板创建记录。

问题来了，这种字段文件怎么保存呢？

有几个问题需要面对：

1. 是否需要独立一个文件保存的问题。

   目前暂时可以认为不需要，单文件管理是最简单的，单独增加一个字段。

2. 它是否需要加密的问题，如果需要加密应该是怎么样的。

   必须要加密，否则太容易通过模板来判断对应字段是用来干什么的了，这样会比较危险。例如有个叫做`bank_card`的字段，明摆着就是6位数字，不要太好猜了，尝试10^6次之后，就可以破解，再用每次得到的密钥去测试其他叫做`description`的字段，能不能解密为一个人类语言，这样可以很容易判断测试的密钥是否正确，为了防止这一点该怎么办？由于项目本身是开源的，所以文件怎么存储非常容易知道。为了防止去对某一个内容进行猜测，比如猜测一个`{"field_name"： <encrypted_content>}`的内容，只能将模板的内容整个进行加密，而且必须加盐，防止攻击一些常见的情况。

3. 还有一个复杂的问题就是模板的同步，是否允许模板被修改，还是必须新建呢？

   如果支持模板修改，那么会怎么样？首先我支持的字段是否有类型？如果有类型的话每个类型的默认值是否都可以是一个空的字符串？还有一点就是万一删除了一个字段，导致不小心丢失了内容怎么办？果然为了防止这种情况还是不得不只能允许新建，不允许修改，但是之后可以提供一个转换功能，将一些条目手动一定到另外一个模板类型，因为模板本身也是一种分组。

4. 还有一个就是用户的一些选项，关于选项到底应该是谁来保管？

   还是不要保存和内核无关的配置比较好。

还有一点就是必须对记录中所有的内容都进行加密才行，包括描述，记录简介，同时模板字段的id必须是随机值，同时对于加密内容的长度，应该选择能够混淆长度的加密算法，要不然一些数字密码的特征太过明显了，比如银行卡就是6位纯数字，如果被发现一个字段是这种6位纯数字，实在太好破解了。

下面是基于上面的一些总结：

```json
{
	"records": {
    	<UUID:record_id>: {
        	"template": <UUID:template_id>,
        	"title": <encrypted_content>,
        	"labels": [<UUID:label_id>],
        	"fields": {
        		<UUID:field_id>: <encrypted_content>
    		}
 		}
	},
	"labels": {
    	<UUID:label_id>: <encrypted_content>
    },
	"templates": {
        <UUID:template_id>: {
        	"template_name": "",
        	"fields": {
        		<UUID:field_id>: {
        			"name": "field1",
        			"optional": true,
        			"type": "password"
    			}
    		}
    	}
    }
}
```

整个格式设计的一个核心就是能够在加密的情况下对整个json进行操作，减少内核部分需要接触明文的函数，最好可以做到只有用户需要的时候短暂地显示明文，在对数据进行更新之类操作的时候完全不接触明文。

## 加密/解密 流程

用户首先输入主密码，然后设置一个8位的pin，我使用pin来进行密钥生成，当然要对pin加盐，然后用这个生成的密钥来对主密码加密，用户只需要输入pin就可以代替主密码了，当然对pin有强制过期时间，之后的一些操作需要使用pin才可以完成，比如设置webdav地址和webdav密码，它们都会被主密码加密，所以用户需要输入主密码之后才能够进行webdav的设置操作。

拉取webdav的密码和地址是加密存储的，只有在用户需要进行拉取的时候才会进行解密。

在拉取了数据文件后，得到的内容如上，显示层可以向内核请求title和label相关数据，将密码项的内容展示出来，用户可以选择密码项，在选择之后，用户输入pin，显示层向内核请求密码项内容，内核层需要验证pin是否有效，然后根据template来向展示层提供处理后的数据。



## 对外接口



### 配置接口



## 技术选择和开发计划

我希望使用wasm来处理内核部分，原因是可以控制内存，会更加安全一些，还有就是学习一下wasm的开发经验，但是到底是rust还是golang呢？我还没有想好，go比较简单，ai写代码很容易写对，rust难度大，ai写不对。但是rust首先是内存控制好，另外是运行库小。

或者另外一个方式，只有关键部分使用rust实现，其他部分还是typescript来实现，也就是涉及到对文档内容加密解密操作的部分是rust实现的，但是一个问题就是前端逻辑是js实现的，也就是明文无论如何都要传递到前端去，当然，我们可以只让前端持有用户选择的记录。



## 测试环境和测试计划

