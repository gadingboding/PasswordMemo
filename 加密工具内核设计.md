来设计一下加密工具的内核功能层吧，由于是分层设计，所以先来完成内核层，内核层的就是为了能够向表示层提供服务的，所以也算是一个前后端分离的项目了。同时还有一个适配层，用来适配不同执行环境，不同浏览器或者node，之所以要支持node，是因为一些测试应该在本地完成，最好变成cicd的一部分。

## 内核功能模块

整个内核层本身就是一个对象，然后对外暴露了一些接口，并不是一个工具集，使用者将它作为全局对象就可以了。

下面来说明一下内核层需要支持的任务：

### 文件管理

需要能够支持文件的读取和保存，操作的对象包含本地文件系统、浏览器存储、webdav等。

由于是分布式环境，文件的同步和更新策略至关重要，绝不能简单地用任一副本覆盖另一副本，这会导致数据丢失。为此，我们采用基于记录的版本控制策略。

1.  **记录独立性**：每条记录都拥有一个全局唯一的UUID，作为其身份标识。
2.  **版本与时间戳**：每条记录都包含一个 `last_modified` 字段，存储其最后修改时间的UTC时间戳。任何对记录的修改都必须更新此时间戳。
3.  **合并逻辑 (Last Write Wins)**：同步时，对本地和远程数据进行逐条记录的比较。
    - **新增**：如果一个UUID只存在于一方，则将其添加到另一方。
    - **更新/冲突**：如果一个UUID在双方都存在，则比较它们的 `last_modified` 时间戳。时间戳较新的记录版本将胜出，并覆盖较旧的版本。这个“最新写入者获胜”的策略能自动解决冲突并保留最新的数据。
4.  **删除处理 (Tombstone)**：为了能在不同设备间同步删除操作，记录不会被直接从数据文件中移除。而是被标记上 `deleted: true`。同步时，其他客户端看到这个标记后，就会在本地删除该记录。这些带有删除标记的“墓碑”记录可以由内核在未来的某个时机进行清理。
5.  **纯本地记录**：支持不参与同步的纯本地记录。这类记录会有一个 `local_only: true` 的标记。在发起同步操作前，内核会先将这些记录过滤掉。

### 状态管理

对整个加密工具的状态进行管理，例如设置自动关闭时间之类的，还有就是保存一个PIN的状态，是否过期，是否能够使用。

### 加密解密

这里需要考虑的问题是到底应该对每个密码进行加密还是对整个文件都加密？为了能够进行管理，应该是对每个密码都进行加密，不只是密码，包括描述之类的东西也一个进行加密，这样文件被拿下了也不会有什么问题。

是的，你关于人类语言的担忧是正确的。如果攻击者知道加密的是自然语言文本，他们就可以用此作为“明文谕示”(oracle)来验证密钥猜测的正确性。对整个JSON结构或特定字段进行加密，可以部分缓解这个问题，但最关键的还是使用强密钥和认证加密（如AES-GCM），后者能验证密文的完整性，错误密钥几乎不可能解密出看似有效的数据。

### 配置管理

## 文件格式设置

如何去实现这个文件格式？

除了密码记录之外，我还需要支持自定义字段，也就是说用户可以创建一个模板来指定，然后通过模板创建记录。

问题来了，这种字段文件怎么保存呢？

有几个问题需要面对：

1.  是否需要独立一个文件保存的问题。

    目前暂时可以认为不需要，单文件管理是最简单的，单独增加一个字段。

2.  它是否需要加密的问题，如果需要加密应该是怎么样的。

    必须要加密，否则太容易通过模板来判断对应字段是用来干什么的了，这样会比较危险。例如有个叫做`bank_card`的字段，明摆着就是6位数字，不要太好猜了，尝试10^6次之后，就可以破解，再用每次得到的密钥去测试其他叫做`description`的字段，能不能解密为一个人类语言，这样可以很容易判断测试的密钥是否正确，为了防止这一点该怎么办？由于项目本身是开源的，所以文件怎么存储非常容易知道。为了防止去对某一个内容进行猜测，比如猜测一个`{"field_name"： <encrypted_content>}`的内容，只能将模板的内容整个进行加密，而且必须加盐，防止攻击一些常见的情况。

3.  还有一个复杂的问题就是模板的同步，是否允许模板被修改，还是必须新建呢？

    如果支持模板修改，那么会怎么样？首先我支持的字段是否有类型？如果有类型的话每个类型的默认值是否都可以是一个空的字符串？还有一点就是万一删除了一个字段，导致不小心丢失了内容怎么办？果然为了防止这种情况还是不得不只能允许新建，不允许修改，但是之后可以提供一个转换功能，将一些条目手动一定到另外一个模板类型，因为模板本身也是一种分组。

4.  还有一个就是用户的一些选项，关于选项到底应该是谁来保管？

    还是不要保存和内核无关的配置比较好。

### 长度规范化填充方案细则

长度规范化填充方案细则 (Padding Scheme)
方案名称: 基于 ISO/IEC 7816-4 的随机化填充

目标: 将任意长度的原始数据填充到预定义的固定长度“桶”中，以隐藏真实长度。填充过程需引入随机性。

填充后数据结构:
[ 原始数据 | 0x80 分隔符 | 随机填充字节... ]

尺寸桶定义 (Size Buckets):
预设一组目标长度桶，单位为字节：
[64, 128, 256, 512, 1024, 2048, 4096]

填充算法 (Pad):
function pad(original_data: Uint8Array): Uint8Array

计算原始数据长度 L = original_data.length。
确定目标尺寸 T：从尺寸桶中找到第一个大于或等于 L + 1 的值。（+1 是为 0x80 分隔符预留空间）。
超大内容处理: 如果 L + 1 大于尺寸桶中的最大值，则抛出错误或按需处理（例如，不填充或使用更大的块）。为简化设计，我们规定所有可加密字段必须能被填充进最大尺寸桶。
计算随机填充的长度 P = T - L - 1。
创建分隔符：const delimiter = new Uint8Array([0x80])。
生成随机填充：使用密码学安全伪随机数生成器（CSPRNG）生成一个长度为 P 的随机字节数组 random_padding。
拼接三部分：[original_data | delimiter | random_padding]，形成最终的填充后载荷。
返回该载荷。
去填充算法 (Unpad):
function unpad(decrypted_payload: Uint8Array): Uint8Array

从后向前遍历 decrypted_payload 字节数组，查找第一个值为 0x80 的字节。
如果未找到 0x80，说明数据已损坏或格式不正确，抛出错误。
如果找到了 0x80，其索引为 i。
原始数据即为从 decrypted_payload 的开头到索引 i 之前的部分。
返回 decrypted_payload.slice(0, i)。

### 标记法与加密增强

`E_MK(value)` 代表 `value` 这个数据在使用**主密钥 (MK)** 加密前，经过了**长度规范化填充**处理。在实际存储中，`E_MK(value)` 是一个Base64编码的字符串，包含了密文以及加密算法所需的元数据（如IV/Nonce）。

### 主数据文件 (`Vault`) 结构

基于以上标记法，主数据文件的结构定义如下，这实现了字段级别的独立加密和元数据保护。

```json
{
  "kdf": {
    "algorithm": "pbkdf2",
    "params": {
      "salt": "...",
      "iterations": 600000,
      "hash": "sha256",
      "keyLength": 32
    }
  },
  "records": {
    "<UUID:record_id>": {
      // --- 同步元数据 (保持明文) ---
      "last_modified": "<UTC_ISO_8601_Timestamp>",
      "deleted": false,
      "local_only": false,
      "template": "<UUID:template_id>",
      "labels": [
        "<UUID:label_id_1>",
        "<UUID:label_id_2>"
      ],
      // --- 核心内容 (独立加密，并经过长度规范化) ---
      "title": E_MK(
      "记录的标题"
      ),
      "fields": {
        // 每个字段的值都独立加密，键是模板中定义的字段UUID
        "<UUID:field_id_from_template>": E_MK(
        "字段的具体秘密内容"
        )
      }
    }
  },
  "labels": {
    // 标签的UUID是明文，用于关联。但标签自身的内容被作为一个整体加密。
    "<UUID:label_id>": E_MK({ "name": "工作标签", "color": "#FF5733" })
    },
	"templates": {
        // 模板的UUID是明文，用于关联。但模板的定义（结构和名称）被作为一个整体加密，
        // 以防止通过模板结构猜测字段内容。
        "<UUID:template_id>": E_MK({
        	"name": "银行卡模板",
        	"fields": [
        		{ "id": "<UUID:field_id_1>", "name": "卡号", "type": "text", "optional": false },
        		{ "id": "<UUID:field_id_2>", "name": "持卡人", "type": "text", "optional": true },
            { "id": "<UUID:field_id_3>", "name": "PIN码", "type": "password", "optional": false }
    		]
    	})
    }
}
```

这里还有一个问题就是关于生成master key所用的salt的问题。由于salt是随机的，就因为不同机器上的salt不一样，从而导致master key不同，也就是在另外一个机器上的加密内容，在本机会出现无法解密的问题。因此，我们需要进行下面的操作:
在vault文件中保存生成master key的salt，还有迭代次数等配置，我们对于配置的实现必须足够灵活，从而可以让我们在之后对加密算法进行切换和允许用户配置。我们需要在vault里面增加一个字段`kdf`，用来作为master key派生的配置：
比如下面我们使用`argon2id`算法
```json
{
  "kdf": {
    "algorithm": "argon2id",
    "params": {
      "salt": "...",
      "memoryCost": 65536,
      "timeCost": 3, 
      "parallelism": 1, 
      "keyLength": 32
    }
  }
}
```
或者是使用`pbkdf2`算法
```json
{
  "kdf": {
    "algorithm": "pbkdf2",
    "params": {
      "salt": "...",
      "iterations": 600000,
      "hash": "sha256",
      "keyLength": 32
    }
  }
}
```
我们需要对每一种加密配置一个类型，使用配置对其初始化，检查参数是否合法，然后在生成的时候使用这个参数进行。
我们还需要支持可以切换加密方式，在修改了kdf中任何一个配置之后，对整个vault和user-profile部分都进行重新加密，我们需要支持暴露出一个api接口，支持用户能够进行配置，上面我提到的kdf配置类型需要暴露给用户，用户进行传入，如果发现和当前有不一致则启动重新加密。


### webdav泄露问题
我们还需要考虑到webdav出现了大规模泄露的问题，这非常有可能发生，在泄露之后攻击者可能会试图寻找一些有价值的目标。 我需要隐藏掉vault文件的一些特征，否则可能会被攻击，在后续的设计当中需要考虑这一点。

### 本地存储 (`localStorage` 或 `IndexedDB`)

这是存储在浏览器本地的数据，用于会话管理和PIN解锁。**所有敏感信息都必须加密。**

```json
{
  "user_profile": {
    "username": "user_example",
    "security_profile": {
      // --- 主密码相关（长期存储）---
      "salt_mp": "base64_encoded_salt_for_master_password",
      "encryptedMK_by_MPKey": "base64_encoded_master_key_encrypted_by_key_from_MP",

      // --- 访问密钥相关（用于PIN解锁）---
      "encryptedMK_by_AK": "base64_encoded_master_key_encrypted_by_AK",

      // --- PIN解锁相关（PIN启用期间存储，有生命周期）---
      "pin_profile": {
        "enabled": true,
        "salt_pin": "base64_encoded_salt_for_pin",
        "encryptedAK_by_PUK": "base64_encoded_access_key_encrypted_by_PUK",
        "expiry_timestamp": 1678886400000 // UTC毫秒时间戳
      }
    },
    // --- WebDAV配置（使用MK加密）---
    "webdav_config": {
        "encrypted_data": E_MK({ "url": "...", "username": "...", "password": "..." })
    }
  }
}
```

## 加密/解密 流程

此流程旨在提供安全的PIN解锁功能，同时将PIN破解的风险与主密码的安全性完全隔离。

#### 密钥定义

- **主密码 (MP)**: 用户设置的强密码，永不存储。
- **主密钥 (MK)**: 32字节高熵密钥，用于加密 `Vault` 中的所有 `E_MK(...)` 内容。
- **访问密钥 (AK)**: 32字节高熵密钥，作为解密 `MK` 的临时凭证，生命周期短。
- **PIN解锁密钥 (PUK)**: 从用户 `PIN` 和盐派生的密钥，仅用于解密 `AK`。
- **`KDF`**: 强密钥派生函数，推荐使用 Argon2id。

#### 1. 首次设置 / 主密码登录

1.  用户输入 `MP`。
2.  内核使用本地存储的 `salt_mp` 计算 `Key_from_MP = KDF(MP, salt_mp)`。
3.  用 `Key_from_MP` 解密 `encryptedMK_by_MPKey` 以获得 `MK` 并载入内存。
4.  此时，应用进入“完全解锁”状态。用户可以查看/编辑数据，设置WebDAV等。

#### 2. 启用PIN解锁

1.  在“完全解锁”状态下（即内存中持有 `MK`），用户设置 `PIN`。
2.  内核执行以下操作：
    a. 生成一个新的高熵随机 `AK` (访问密钥)。
    b. 生成一个新的 `salt_pin`。
    c. 计算 `PUK = KDF(PIN, salt_pin)`。
    d. 使用 `PUK` 加密 `AK`，得到 `encryptedAK_by_PUK`。
    e. 使用 `AK` 加密 `MK`，得到 `encryptedMK_by_AK`。
    f. 设置 `expiry_timestamp`。
    g. 将 `encryptedMK_by_AK` 和整个 `pin_profile` 对象（包含`enabled`, `salt_pin`, `encryptedAK_by_PUK`, `expiry_timestamp`）存入本地存储。

#### 3. 使用PIN解锁

1.  应用启动时，检测到 `pin_profile` 存在且未过期。
2.  提示用户输入 `PIN`。
3.  内核执行以下操作：
    a. 使用存储的 `salt_pin` 和用户输入的 `PIN` 计算 `PUK = KDF(PIN, salt_pin)`。
    b. 用 `PUK` 尝试解密 `encryptedAK_by_PUK`。
    _ **成功**：获得 `AK`，将其载入内存。
    _ **失败**：PIN错误。记录失败次数，达到阈值后清除 `pin_profile`，强制主密码登录。
4.  **用 `AK` 获取 `MK`**:
    a. 使用内存中的 `AK` 解密 `encryptedMK_by_AK` 得到 `MK`。
    b. 现在内存中有了 `MK`，应用进入“完全解锁”状态。

5.  PIN遗忘恢复机制
    如果用户忘记了PIN，应提供通过主密码(MP)恢复并重新进入系统的能力。
    当用户选择“忘记PIN”或在PIN解锁失败达到阈值后，引导用户输入主密码(MP)。
#### 4. 显示数据

表示层向内核请求记录列表。内核使用内存中的 `MK` 解密各条记录的 `title` 字段后返回。当用户选择某条具体记录时，内核再按需解密该记录的 `fields` 内容，并安全地传递给表示层。

## 对外接口

### 配置接口

## 技术选择和开发计划

我希望使用wasm来处理内核部分，原因是可以控制内存，会更加安全一些，还有就是学习一下wasm的开发经验，但是到底是rust还是golang呢？我还没有想好，go比较简单，ai写代码很容易写对，rust难度大，ai写不对。但是rust首先是内存控制好，另外是运行库小。

或者另外一个方式，只有关键部分使用rust实现，其他部分还是typescript来实现，也就是涉及到对文档内容加密解密操作的部分是rust实现的，但是一个问题就是前端逻辑是js实现的，也就是明文无论如何都要传递到前端去，当然，我们可以只让前端持有用户选择的记录。

注意：在早期开发阶段，我们完全使用typescript来完成开发，等到整体流程验证通过后，再将关键部分切换为rust的wasm，不过我们要处理好这部分的接口，保证之后切换的时候可以足够顺畅。

## 模块设计

认证与会话管理器 (Auth & Session Manager)
这个模块是内核的“门卫”和状态控制器。它负责验证用户身份（通过主密码或PIN），管理内核的锁定/解锁状态，并控制着安全会话的生命周期，例如在用户闲置时自动锁定保险库。

加密引擎 (Cryptography Engine)
这是整个系统的安全核心。所有与密码学相关的复杂操作都在此模块中进行。它负责从用户密码安全地派生出密钥，并使用这些密钥来加密和解密所有敏感数据，确保信息在存储和传输过程中的机密性和完整性。

保险库管理器 (Vault Manager)
该模块是内存中的数据中枢。当保险库被解锁后，它以解密的形式持有并管理所有的用户数据，如登录记录、笔记等。它处理所有的数据操作请求，比如创建、读取、更新和删除记录。

同步协调器 (Sync Coordinator)
此模块的专长是处理数据同步。当需要将本地数据与远程服务器（或其他设备）的数据合并时，它会介入。它负责比较两个版本的数据，智能地解决冲突，并生成一个统一、最新的数据视图，以确保多设备间的数据一致性。

配置管理器 (Configuration Manager)
这是一个专门用于管理应用程序设置的模块。它负责处理那些需要与保险库一同安全存储和同步的配置信息，例如远程同步服务器的地址和凭据。它确保这些配置也像用户数据一样被加密保护。

## 测试环境和测试计划
