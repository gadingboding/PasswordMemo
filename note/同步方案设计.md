# 同步方案设计
---
time: 20250826
---

由于我只有前端，如何来通过webdav进行同步？特别是需要能够处理冲突的问题。
所以我在vault对象中增加了一个`history`字段，表示历史编号列表，整体看起来会是这样的：
```json
{
  "history": [
    "id1",
    "id2"
  ]
}
```
每次同步之前会在history后新增一条例如上面会插入`"id3"`，其实之前设计中是每次修改history增加一条的，但是实际上会产生对其他地方的版本产生影响的时候只在同步进行的时候， 所以说实际上只需要在同步之前增加一个记录就可以和其他的内容进行区别了，这个history可以认为是同步版本id。

在同步进行之前会拉取远端的版本，比较两者的history字段，如果远端的序列`history_remote`是本地的序列`history_local`的前缀，那么说明`history_local`就是在远端的这个版本上面进行的更新，可以直接覆盖掉远端的版本，同时`history_local`也一起同步了。

同步随时可以撤销，所以不要直接修改history字段的内容，只是假定多了一条新记录，同时history的记录应该和git的commit id类似。

如果不是前缀，那么说明是基于另外的版本修改的，那么开始合并，合并需要将远程的内容拉取到本地来进行，按照之前描述的做法，我们可以通过修改时间来实现智能合并，我暂时还没有想到通过修改时间会有什么问题，我们不考虑同时修改这种极端的情况，密码管理器不应该被同时修改，除非被盗了。

当然暂时只支持这种“智能合并”的方式，之后还是可以考虑支持一下用户选择的，主要是操作起来很麻烦，这个功能应该由core来实现，但是问题是core处理这些状态的时候挺麻烦的，首先需要记住当前是“冲突解决”状态，然后针对同一条记录，用户层返回使用远程还是本地。这个对于用户层ui来说也很麻烦。

说完了上传，其实还有拉取的问题，不过是差不多的。 拉取也是一样，如果本地的`history_local`是`history_remote`的前缀，那么说明远端只是单纯的更新版本，直接覆盖即可，如果远端已经被其他服务端更新了，那么也进入到冲突解决状态，通过“智能合并”的方案解决。 同步之前不修改`history_local`，同步完成之后本地的history变为`history_remote`的内容。

唯一一个问题就是history字段会不断增长，不过这不是一个很明显的问题，一年也就同步几百次差不多了，十年之后就几MB而已。





